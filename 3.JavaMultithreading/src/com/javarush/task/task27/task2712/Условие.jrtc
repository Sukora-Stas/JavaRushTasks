taskKey="com.javarush.task.task27.task2712.big07"

Ресторан(7)

При выборе, с какого класса начать, старайся найти тот, который используют другие, и который сам ничего не использует.
В нашем случае - это хранилище рекламных роликов (AdvertisementStorage).
Мы решили, что оно будет единственным в ресторане и сделали его синглтоном.
Опишем его.

1. Видео должно где-то храниться, пусть это будет список.
Создадим поле videos и инициализируем его пустым листом.
Подумай, должно ли поле videos иметь возможность менять свое значение?

2. Чтобы как-то работать с видео, создай публичные методы:
2.1. list() - который вернет список всех существующих доступных видео.
2.2. add(Advertisement advertisement) - который добавит новое видео в список videos.

3. В конструкторе класса добавим в список videos какие-то данные. У меня это:
Object someContent = new Object();
new Advertisement(someContent, "First Video", 5000, 100, 3 * 60) // 3 min
new Advertisement(someContent, "Second Video", 100, 10, 15 * 60) //15 min
new Advertisement(someContent, "Third Video", 400, 2, 10 * 60)  //10 min

4. В AdvertisementManager создадим final поле-ссылку на экземпляр AdvertisementStorage и назовем ее storage.
Не забудь инициализировать созданное поле!


Требования:
1.	В классе AdvertisementManager должно быть создано поле storage содержащее экземпляр класса AdvertisementStorage.
2.	В классе AdvertisementStorage список videos должен быть объявлен с модификатором доступа final.
3.	В классе AdvertisementStorage метод list должен возвращать список videos и быть публичным.
4.	В классе AdvertisementStorage метод add должен принимать один параметр типа Advertisement и добавлять полученный объект в список videos.
5.	В конструкторе класса AdvertisementStorage в список videos должно быть добавлено несколько объектов типа Advertisement.


Ресторан(6)

Заказ создается, потом готовится поваром, а после этого относится посетителю. К тому же считается время выполнения заказа.
Будем считать, что первая часть задания выполнена.
Перейдем ко второй - пока заказ готовится, на планшете должна показываться реклама.
Определим, что такое реклама.

Реклама - это видео определенной продолжительности. Также известно, что кто-то оплатил количество показов.
Будем считать, что у нас известно количество оплаченных показов, общая стоимость всех показов и сам рекламный ролик.

1. Для связанного с рекламой функционала создадим пакет ad.

2. Создадим класс Advertisement(Рекламное объявление) в пакете ad, у которого будут следующие поля:
Object content - видео
String name - имя/название
long initialAmount - начальная сумма, стоимость рекламы в копейках. Используем long, чтобы избежать проблем с округлением
int hits - количество оплаченных показов
int duration - продолжительность в секундах
Модификаторы доступа расставь самостоятельно.

3. В классе Advertisement создадим конструктор с порядком аргументов, соответствующим перечисленной последовательности всех полей класса

4. В этом же пакете создадим еще два класса:
AdvertisementStorage - хранилище рекламных роликов.
AdvertisementManager - у каждого планшета будет свой объект менеджера,
который будет подбирать оптимальный набор роликов и их последовательность для каждого заказа.
Он также будет взаимодействовать с плеером и отображать ролики.

5. Так как хранилище рекламных роликов AdvertisementStorage единственное для всего ресторана, то сделаем его синглтоном.



Ресторан(5)

Сейчас повар готовит блюда моментально. На самом деле приготовление занимает какое-то время.
Нам нужно вычислить время приготовления всего заказа, чтобы потом подбирать рекламные ролики для этого времени.

1. Предположим, что нам известно время приготовления каждого блюда в минутах. Захардкодим его в классе Dish.
1.1. Измени создание элементов enum - Fish(25), Steak(30), Soup(15), Juice(5), Water(3);
1.2. Создай поле private int duration с геттером.
Чтобы создать геттер, нажмите Alt+Insert и выберите пункт Getter. Далее выберите имя поля и нажмите OK(Enter).

2. Добавим возможность посчитать продолжительность приготовления всего заказа.
Куда его добавить???
2.1. Если в класс Cook, то повар сможет считать продолжительность приготовления заказа.
Чтобы другие классы могли получить эту информацию, необходимо будет получить доступ к объекту Cook.
2.2. Если в класс Order, то имея доступ к заказу всегда можно узнать продолжительность приготовления.
2.3. Выбери правильное место из п.2.1. и п.2.2. и добавьте метод pubic int getTotalCookingTime(),
который посчитает суммарное время приготовления всех блюд в заказе.
2.4. Добавим нашему повару вывод в консоль этой информации. Пусть теперь выводится аналогичное сообщение:
Start cooking - Your order: [Soup, Juice, Water] of Tablet{number=5}, cooking time 23min

Наведем красоту:
3. Запустим приложение и сразу введем 'exit'. Вывод получился не очень красивым.
Сделай так, чтобы если в заказе нет блюд, он не отправлялся повару. Найди это место и реализуйте логику.
В классе Order создай вспомогательный метод public boolean isEmpty(), который будет определять, есть ли какие либо блюда в заказе.



Ресторан(4)

Что мы имеем? Повар приготовил блюда, пора их уносить, а официант не знает об этом.
Нужно уведомить официанта, что пора забирать заказ с кухни.
Ситуация аналогична предыдущему заданию, поэтому снова будем использовать паттерн Observer.

1. Создадим класс Waiter(Официант) в пакете kitchen, он будет относить заказы назад к столику. Официант будет безымянным.

2. Cook(Повар) готовит заказы, а Waiter их обрабатывает. Расставь правильно Observer и Observable между Waiter и Cook.

3. Метод void update будет выводить в консоль сообщение о том, какой заказ и кем был приготовлен:
order + " was cooked by " + cook

4. В классе наследнике Observable перед отправкой заказа сделаем следующее:
4.1. Установим флаг setChanged()
4.2. Отправим наблюдателю заказ - notifyObservers(order);

5. Пишем main.
Для объекта Observable добавляем свой объект Observer. См. п.2 и описание паттерна в wikipedia
Называем повара, имя не влияет на тесты. В моем варианте - это Amigo :)

Сверим выводы в консоль. Пример моего вывода:
Your order: [Water] of Tablet{number=5}
Start cooking - Your order: [Water] of Tablet{number=5}
Your order: [Water] of Tablet{number=5} was cooked by Amigo



Ресторан(3)

Сейчас мы можем создавать заказы. Давай сделаем так, чтобы они автоматически поступали к повару.
Есть много различных способов реализации данной функциональности.
Почитай про паттерн Observer - http://en.wikipedia.org/wiki/Observer_pattern
Он уже реализован в java, и мы его будем использовать.

1. Создадим класс Cook(Повар) в пакете kitchen, он будет готовить. Пусть в конструкторе приходит его имя, которое выводится методом toString.

2. Tablet создает заказы, а Cook их обрабатывает. Расставь правильно Observer и Observable между Tablet и Cook.

3. Метод void update(Observable observable, Object arg), который необходимо реализовать, принимает два параметра.
-observable - объект, который отправил нам значение
-arg - само значение, в нашем случае - это объект Order
На данном этапе мы будем лишь имитировать обработку и выведем в консоль "Start cooking - " + order

3. Пишем main.
Для объекта Observable добавляем свой объект Observer. См. п.2 и описание паттерна в wikipedia
Называем повара, имя не влияет на тесты. В моем варианте - это Amigo : )

Сверим выводы в консоль. Пример моего вывода:
Your order: [Soup] of Tablet{number=5}
Start cooking - Your order: [Soup] of Tablet{number=5}

4. Не забудь сразу после создания заказа и вывода информации о нем в консоль (найдите это место в коде) сделать следующее:
4.1. Установить флаг setChanged()
4.2. Отправить обсерверу заказ - notifyObservers(order);

5. Также внесем небольшое изменение. Сделай так чтобы метод createOrder возвращал текущий заказ или null, если заказ создать не удалось.



Ресторан(2)

1. Мы много работаем с консолью. Пора создать единую точку взаимодействия.
Создай класс ConsoleHelper с единственным BufferedReader, через который будем работать с консолью.
Запомни, этот класс не хранит никаких данных и состояний, поэтому все методы будут статическими.
Создай в нем три метода:
-writeMessage(String message) - для вывода message в консоль
-String readString() - для чтения строки с консоли
-List<Dish> getAllDishesForOrder() - просит пользователя выбрать блюдо и добавляет его в список.
Выведи список всех блюд и попроси пользователя ввести строку - название блюда.
Введенное 'exit' означает завершение заказа.
В случае, если введенное блюдо не представлено в меню, выведи сообщение о том, что такого блюда нет и продолжи формирование заказа.
Исключения ввода-вывода бросай выше, на этом уровне не понятно, что с ними делать.

2. Сделай рефакторинг - работа с консолью должна быть только через класс ConsoleHelper.

3. Вернемся к классу Order: в нем есть ссылка на планшет, и еще есть список выбранных блюд.
Инициализируй список dishes в конструкторе, вызвав метод getAllDishesForOrder из ConsoleHelper.

4. Перепиши метод toString в классе Order. Пусть он возвращает пустую строку, если нет блюд в заказе, иначе
вывод должен быть аналогичным примеру в порядке добавления блюд. Используй ConsoleHelper.
Также измени метод toString в классе Tablet (внутри класса Tablet нажмите Alt+Insert -> toString()).
Пример:
Your order: [Juice, Fish] of Tablet{number=5}

5. У нас все завязано на работу с консолью. Однако, при возникновении исключений, наше приложение умрет.
Чтобы узнать причину - добавим в Tablet статическое поле logger типа java.util.logging.Logger, инициализированное именем класса (Logger.getLogger(Tablet.class.getName())).

6. В методе createOrder класса Tablet обработаем исключения ввода-вывода.
Запишем в лог "Console is unavailable.". Уровень лога - SEVERE - это самый серьезный уровень, мы не можем работать.
Также в методе createOrder класса Tablet должен быть создан новый заказ.

7. Надо начинать тестировать наше приложение.
Добавьте в main создание планшета и создание заказа - new Tablet(5).createOrder();



