taskKey="com.javarush.task.task27.task2712.big23"

Ресторан(23)

Это всё! Красоту можешь наводить самостоятельно.

Например:
1. Для трэдов обычно используют класс ThreadLocalRandom вместо Random. Отрефакторь код, замени Random на ThreadLocalRandom.
2. Сделай Waiter таском, чтобы он работал как трэд (убери Observer). Сделай очередь приготовленных заказов, официант пусть берет заказы из нее и относит на столы.
3. Запиши в ивент-лог событие NoAvailableVideoEventDataRow тогда, когда невозможно подобрать видео. Выдавай это событие директору.
4. Напиши UI, например, на Swing.

Твои достижения:
1. Разобрался с паттерном Observer.
2. Прокачал скилл написания рекурсии.
3. Познакомился с методом реализации ведения статистики.
4. Стал больше знать и уметь.
5. Увидел, как раскладывать задачу на подзадачи.
6. Продвинулся на шаг ближе к работе джава программистом.

Поздравляю!


Требования:
1.	Ты отлично поработал. Большая задача пройдена!


Ресторан(22)

К сожалению, заказы все еще не готовятся параллельно. Вот как работает наш трэд из предыдущего задания.
Он находит повара, потом находит заказ, отдает заказ повару методом startCookingOrder, потом ждет окончания приготовления,
и только после этого переходит к следующему заказу. Так происходит потому, что все действия внутри одного трэда -
последовательные. Мы не можем в пределах одного трэда выполнять параллельные процессы.
Нам нужна стандартная Producer-Consumer реализация.
RandomOrderGeneratorTask - у нас Producer, т.к. производит заказы
Cook - это Consumer, т.к. обрабатывает заказы

1. Перенеси поле-очередь из OrderManager в Restaurant, сделай ее приватной константой.
2. Добавь поле-очередь и сеттер в класс Cook, сразу после создания повара используя созданный сеттер установи ему
константу из п.1. в качестве значения для созданного поля.
3. Tablet - не должен быть Observable. Убери все зависимости.
4. В Tablet создай сеттер и установи ссылку на очередь (п.1) при создании планшета.
5. В Tablet часть логики, которая уведомляет Observer-а, замени на такую, которая добавляет заказ в очередь.

6. В методе main создай и запусти трэды на основании тасок Cook.
7. Из класса StatisticManager удали сет поваров, его геттер и метод register(Cook cook).
8. Сделай класс Cook - таском(Runnable). Перенеси логику из трэда внутри конструктора OrderManager в метод run класса Cook.
9. Удали класс OrderManager и в методе main исправь зависимость Observer-Observable.



Ресторан(21)

Продолжаем фиксить баг.

Сейчас все заказы поступают в очередь, но не доходят до поваров.
Сделаем так, чтобы OrderManager находил любого свободного повара и отдавал ему заказ. Для реализации данной логики
нам понадобится демон-трэд. Он будет проверять наличие заказа в очереди, брать свободного повара и отдавать ему заказ.

Нам понадобится метод, который определит, занят повар или нет.
1. В классе Cook создай поле boolean busy с геттером.
2. В начале метода startCookingOrder поставьте busy в true, а в конце метода в false.
3. В методе startCookingOrder сымитируй задержку при приготовлении блюда, поставь слип в 10-кратном размере от времени приготовления заказа.
приготовления заказа, т.е. если заказ готовится 30 минут, то задержка будет 30*10 миллисекунд.
4. Чтобы получить список всех поваров, в классе StatisticManager добавь геттер для поля, которое заполняется в методе register(Cook cook).

5. В конструкторе OrderManager создай и запусти демон-трэд. Логика метода run:
каждые 10 миллисекунд проверять очередь. Если в очереди есть заказ, то найти свободного повара и передать
ему заказ (метод startCookingOrder), если нет свободного повара или нет заказов в очереди, то ждать дальше.



Ресторан(20)

Фикс бага - планшет направляет свой заказ всем известным ему поварам.
Ожидаемое поведение: планшет направляет свой заказ в очередь, свободный повар берет заказы из очереди.

Есть два варианта реализации такого функционала:
1) Каждый планшет хранит ссылку на очередь и толкает в нее новый свой заказ.
2) Планшет толкает свой заказ в Observer, который хранит в себе ссылку на очередь. Observer заносит заказ в очередь.

Мы пойдем по второму пути.
1. Создай класс OrderManager, который будет Observer для планшетов.
2. В классе OrderManager создай поле orderQueue типа LinkedBlockingQueue<Order>. В него складывай все заказы, поступающие в метод update.
3. Класс Cook теперь - НЕ Observer.
4. В классе Cook создай метод void startCookingOrder(Order order), в который перенеси логику из метода update.
5. Удали метод update из класса Cook.
6. В методе main расставь зависимость Observer-Observable в связи с вышеперечисленными изменениями.



Ресторан(19)

Нам осталось доделать метод main.

Сперва давай сравним параметры конструктора RandomOrderGeneratorTask.
Пожалуйста, сделай сигнатуру такой же, как у меня:
public RandomOrderGeneratorTask(List<Tablet< tablets, int interval)

В методе main:
1. Удали создание хардкоженного планшета и вызова его метода createOrder().
2. Создай второго повара.
3. Зарегистрируй поваров используя класс StatisticManager.
4. Для второго повара и всех планшетов расставь зависимость Observer-Observable.
5. Создай список объектов-планшетов 5 штук, инициализируйте его в цикле.
6. Создай и запустим трэд на основе объекта RandomOrderGeneratorTask.
7. Через секунду прерви его и посмотри на вывод в консоль.

Уупс, два повара готовят один и тот же заказ 8-О

Такой аутпут получился потому, что Observable информирует всех своих Observer-ов, т.е. планшет направляет свой заказ всем известным ему поварам.
Такое поведение нам не подходит, поэтому будем исправлять его в следующем задании.

P.S. Не забудь остановить тред!



Ресторан(18)

Сейчас у нас один планшет и 1 повар.
Давай создадим несколько планшетов, которые будут рандомно генерировать заказы, и сделаем два повара.

1. В классе Restaurant создай ПРИВАТНУЮ статическую константу int ORDER_CREATING_INTERVAL = 100.

2. В отдельном классе создай таск(Runnable) RandomOrderGeneratorTask. Этот таск должен:
2.1. Хранить список всех планшетов
2.2. Используя Math.random выбирать случайный планшет.
2.3. У RandomOrderGeneratorTask должен быть только один единственный метод.
2.4. Генерировать случайный заказ каждые ORDER_CREATING_INTERVAL миллисекунд для планшета из п.2.2. (не печатай стек-трейс)
Сейчас заказ создается в методе createOrder в классе Tablet.
В классе Tablet создай метод void createTestOrder() с похожей функциональностью,
который будет случайным образом генерировать заказ со случайными блюдами не общаясь с реальным человеком.
Все необходимые данные передай в конструкторе.
Подсказка:
а) создай класс TestOrder - наследник Order - в пакете родителя.
б) в классе Order создай protected метод initDishes(), в котором инициализируй dishes. Вызови этот метод в конструкторе
в) сделай поле dishes protected
г) переопредели initDishes в классе-наследнике TestOrder. Сделай инициализацию случайным набором блюд.
д) вместо создания объекта Order в методе createTestOrder() класса Tablet, создавай объект класса TestOrder.
Весь другой функционал метода createTestOrder оставь прежним

3. Отрефакторь методы createTestOrder() и createOrder(): в одном из методов выдели код, который повторяется в обоих методах,
и нажми Ctrl+Alt+M, введи любое имя метода и нажми ОК. IDEA предложит заменить этот код во втором методе, подтверди.



